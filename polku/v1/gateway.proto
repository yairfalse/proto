// gateway.proto - POLKU Gateway service definition
//
// POLKU is an open-source pluggable gRPC event gateway.
// It's format-agnostic - users provide plugins for their specific formats.
//
// Supports two modes:
//   1. Transform mode: Clients send raw bytes, InputPlugins transform them
//   2. Pass-through mode: Clients send pre-formatted events, no transformation
//
// Users can extend POLKU by implementing:
//   - InputPlugin: Transform source-specific bytes → Event
//   - OutputPlugin: Send Events to any destination

syntax = "proto3";

package polku.v1;

option go_package = "github.com/yairfalse/proto/gen/go/polku/v1;polkuv1";

// Import the Event type from the core event proto
import "polku/v1/event.proto";

// Gateway service - the main entry point for event ingestion
service Gateway {
    // Bidirectional streaming for high-throughput event ingestion
    rpc StreamEvents(stream IngestBatch) returns (stream Ack);

    // Unary RPC for single event submission
    rpc SendEvent(IngestEvent) returns (Ack);

    // Health check endpoint
    rpc Health(HealthRequest) returns (HealthResponse);
}

// Batch of events for streaming ingestion
message IngestBatch {
    string source = 1;      // Source identifier (e.g., "my-agent", "otel-collector")
    string cluster = 2;     // Cluster/environment identifier

    // Either raw bytes (needs plugin transformation) or pre-formatted events
    oneof payload {
        RawPayload raw = 3;
        EventPayload events = 4;
    }
}

// Raw bytes payload - requires InputPlugin transformation
message RawPayload {
    bytes data = 1;         // Serialized source-specific format
    string format = 2;      // Format hint: "protobuf", "json", "msgpack", etc.
}

// Pre-formatted events - pass-through mode (no transformation)
message EventPayload {
    repeated polku.event.v1.Event events = 1;
}

// Single event for unary ingestion
message IngestEvent {
    string source = 1;
    string cluster = 2;

    oneof payload {
        bytes raw = 3;                      // Raw bytes (needs transformation)
        polku.event.v1.Event event = 4;     // Pre-formatted event (pass-through)
    }

    string format = 5;      // Format hint for raw payload
}

// Acknowledgment response
message Ack {
    repeated string event_ids = 1;      // Successfully processed event IDs
    repeated AckError errors = 2;       // Errors for failed events
    int64 buffer_size = 3;              // Current buffer size (for backpressure)
    int64 buffer_capacity = 4;          // Max buffer capacity

    // Middleware drop statistics (helps clients understand WHY events aren't processed)
    // These are cumulative counts since connection start.
    MiddlewareStats middleware_stats = 5;
}

// MiddlewareStats provides visibility into the middleware pipeline.
// Clients can use this to distinguish between:
//   - Backpressure (buffer full) → slow down, events will be processed
//   - Rate limiting → you're sending too fast, events are dropped
//   - Sampling → intentional drops by policy, expected behavior
message MiddlewareStats {
    // Rate limiter drops (client exceeding allowed rate)
    int64 rate_limited_count = 1;

    // Sampler drops (intentional sampling, e.g., 10% of network events)
    int64 sampled_out_count = 2;

    // Dedup drops (duplicate event IDs within window)
    int64 dedup_count = 3;

    // Filter drops (events filtered by CEL rules)
    int64 filtered_count = 4;

    // Buffer full drops (backpressure overflow)
    int64 buffer_overflow_count = 5;

    // Total events received (before any middleware)
    int64 total_received = 6;

    // Total events forwarded to Ahti (after all middleware)
    int64 total_forwarded = 7;
}

message AckError {
    string event_id = 1;
    string code = 2;
    string message = 3;
}

// Health check
message HealthRequest {}

message HealthResponse {
    bool healthy = 1;
    map<string, ComponentHealth> components = 2;
    int64 uptime_seconds = 3;
    uint64 events_processed = 4;
}

message ComponentHealth {
    bool healthy = 1;
    string message = 2;
}

// =============================================================================
// PORTTI SERVICE - K8s API event ingestion
// =============================================================================
//
// Optional service for receiving K8s control plane events from PORTTI.
// If you don't use PORTTI, you can ignore this service.

// PorttiService receives K8s events from PORTTI collectors
service PorttiService {
    // Send a single K8s event
    rpc SendK8sEvent(K8sEvent) returns (SendResponse);

    // Stream K8s events for high-throughput ingestion
    rpc StreamK8sEvents(stream K8sEventBatch) returns (stream Ack);
}

// K8s event from PORTTI (matches portti/pkg/proto format)
message K8sEvent {
    string id = 1;                      // Event ID (ULID)
    int64 timestamp_unix_nano = 2;      // Unix timestamp in nanoseconds
    string resource = 3;                // Resource type: deployment, pod, service, etc.
    string action = 4;                  // Action: create, update, delete
    string namespace = 5;               // K8s namespace
    string name = 6;                    // Resource name
    bytes object = 7;                   // JSON-encoded K8s object
    bytes old_object = 8;               // For updates (previous state)
    string cluster_id = 9;              // Cluster identifier
}

// Batch of K8s events for streaming
message K8sEventBatch {
    repeated K8sEvent events = 1;
    string cluster_id = 2;
}

// Simple response for unary RPCs
message SendResponse {
    bool success = 1;
    string error = 2;                   // Error message if success=false
}
